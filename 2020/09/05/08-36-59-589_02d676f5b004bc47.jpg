<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>UpCoder coding blog</title>
    <!--<link rel="stylesheet" href="/static/css/minified.css" type="text/css"/>-->
    <link rel="stylesheet" href="/static/css/framework.css" type="text/css"/>
    <link rel="stylesheet" href="/static/css/blog.css" type="text/css"/>
    <link rel="stylesheet" href="/static/css/pygments_native.css" type="text/css"/>
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed"/>
</head>

<body>
    <div id="header">
        
            <span class="blogName"><a style="display:inline" href="/">UpCoder</a></span>
            <span class="tagLine">code it Up!</span>
            <span>c++, python, game AI, bitcoin</span>
        
    </div>
    <div class="colmask rightmenu">
        <div class="colleft">
            <div class="main-content">
                
    
    <div class="summaryBlock">
        <div class="time">Oct. 13, 2019, 2:14 p.m.</div>
        <div class="titleBlock">
            <a href="/20/cc-include-guidelines">
                <h1 class="title">C/C++ Include Guidelines</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>Some (opinionated) guidelines for include file organisation in C/C++.</p></div>
            <a href="/20/cc-include-guidelines">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">May 31, 2018, 3:33 p.m.</div>
        <div class="titleBlock">
            <a href="/19/automatic-object-linkage-with-include-graphs">
                <h1 class="title">Automatic Object Linkage, with Include Graphs</h1>
            </a>
            
            <h1 class="tagline">(Source code sharing without static libraries)</h1>
            
        </div>
        <div class="summary">
            <div class="body"><p>In this post I describe an alternative approach to
sharing source code elements between multiple build targets.</p>
<p>It's based on a custom build process I implemented at PathEngine
for our C and C++ code-base
(but the core ideas could also be relevant to other languages with compilation to object files).</p>
<p>We'll need to enforce some constraints on the way the source code is set up,
notably with regards to header file organisation,
but can then automatically determine what to include in the link operation for each build target,
based on a graph of include relationships extracted from the source files.</p>
<p>The resulting dynamic, fine grained, object-file centric approach to 
code sharing avoids the need for 
problematic static library decomposition,
and the associated 'false dependencies'. </p></div>
            <a href="/19/automatic-object-linkage-with-include-graphs">Post</a>,
            <a href="/19/automatic-object-linkage-with-include-graphs#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Sept. 23, 2017, 3:12 p.m.</div>
        <div class="titleBlock">
            <a href="/18/static-libs-do-not-modular-make">
                <h1 class="title">Static Libs Do Not Modular Make</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>A cautionary tale about <a href="https://en.wikipedia.org/wiki/Static_library">statically-linked libraries</a>, as generated by C/C++ build tools.</p>
<p>As a project accumulates features, and <em>complexity</em>, it gets harder to understand exactly what's going on,
and to find your way around the source code. You need to find some way to organise the code and try and keep things manageable.</p>
<p>A common idea, in this situation, is to group some source files together to split out as a static library.</p>
<p>I'm going to argue that this actually does very little, in itself, to increase modularity, can
have the effect of significantly <em>increasing</em> dependencies, and is maybe not such a good idea, after all.</p></div>
            <a href="/18/static-libs-do-not-modular-make">Post</a>,
            <a href="/18/static-libs-do-not-modular-make#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Feb. 16, 2017, 2:52 p.m.</div>
        <div class="titleBlock">
            <a href="/17/who-owns-who">
                <h1 class="title">Who Owns Who?</h1>
            </a>
            
            <h1 class="tagline">(Inverting the PathEngine ownership graph)</h1>
            
        </div>
        <div class="summary">
            <div class="body"><p>Designing an API with creation and destruction of objects can be tricky,
particularly if the objects have dependency relationships. </p>
<p>How do we ensure that constructed API objects get destroyed at the appropriate time (and are not 'leaked')?
How do we prevent code from attempting to access objects after destruction?
And how do we do all this in situations where some objects depend on the existence of other objects? </p>
<p>In this post I talk about how I approached this in <a href="http://pathengine.com">PathEngine</a>
(a pathfinding library, in C++).</p>
<p>When I first designed the PathEngine API, I chose an approach based on larger objects each owning a set of smaller 'contained' objects.
That kind of worked out, but it turns out there's another, much better way to do this.
And so it was that I recently found myself going through the SDK and <em>turning the whole thing upside down</em>.</p></div>
            <a href="/17/who-owns-who">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Dec. 29, 2016, 4 p.m.</div>
        <div class="titleBlock">
            <a href="/16/skeleton-meshes">
                <h1 class="title">Skeleton Meshes</h1>
            </a>
            
            <h1 class="tagline">(Break it all apart!)</h1>
            
        </div>
        <div class="summary">
            <div class="body"><p>This post explores a slightly unusual design choice for some key data structures at <a href="http://pathengine.com">PathEngine</a>.</p>
<p>More specifically, it's about
<a href="https://en.wikipedia.org/wiki/Polygon_mesh">polygon mesh</a> data structures (in C++),
and follows on from a previous post
<a href="http://upcoder.com/13/vector-meshes">about polygon meshes 'in the style of std::vector'</a>.</p>
<p>One of the consequences of a vector-like approach is
that mesh elements can be referenced by index,
and then accessing elements by index means we can <em>break stuff apart</em>.</p>
<p>It's a story of violated object oriented programming principles, broken encapsulation,
and unsafe code, but the code we end up with is then <em>more functional</em> and a lot more fun to work with!</p></div>
            <a href="/16/skeleton-meshes">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Nov. 6, 2015, 5:52 p.m.</div>
        <div class="titleBlock">
            <a href="/15/measure-memory-allocation-cost-by-eliminating-it">
                <h1 class="title">Measure Memory Allocation Cost, by Eliminating It</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>Over the years, I've learnt to be suspicious of any dynamic allocation in performance critical code,
and moving allocations back up the call stack can often yield significant speedups.</p>
<p>But I'm guilty of being a little religious about this, on some occasions, and this hasn't always been for the best.</p>
<p>Dynamic allocation helps a lot with writing flexible and robust code.
Changing code to remove dynamic allocations can make the code more complicated, brittle, and harder to maintain,
and sometimes generalised memory allocation is really just the best tool for the job.</p>
<p>The first rule of optimisation is to measure.
In this post I show how to measure when and where
dynamic allocation is actually a significant overhead (and a worthwhile optimisation target),
in a simple platform independent way.</p>
<p>(Sample code is in C++ but the core idea is straightforward and can be applied in other languages.)</p></div>
            <a href="/15/measure-memory-allocation-cost-by-eliminating-it">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Aug. 26, 2015, 4:21 p.m.</div>
        <div class="titleBlock">
            <a href="/14/pre-rendering-pdfs-for-mobile-devices">
                <h1 class="title">Pre-Rendering PDFs for Mobile Devices</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>So I wanted to look up some local travel info, the other day.</p>
<p>There's a detailed PDF file available with exactly the information
I need, but my smart-phone really struggles with this heavy-weight PDF.</p>
<p>Luckily, it turns out to be easy to pre-render the PDF to a big old jpeg
and view this image with my phone's built-in image viewer.</p>
<p>This is so straightforward and convenient, I might as well share the
details for the process here.</p></div>
            <a href="/14/pre-rendering-pdfs-for-mobile-devices">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">July 29, 2015, 5:07 p.m.</div>
        <div class="titleBlock">
            <a href="/13/vector-meshes">
                <h1 class="title">Vector Meshes</h1>
            </a>
            
            <h1 class="tagline">(Polygon meshes in the style of std::vector)</h1>
            
        </div>
        <div class="summary">
            <div class="body"><p>I remember that when the STL came out, vectors were quite a surprising new way
to approach dynamic arrays.
In this post we'll look at some of the implications of applying the vector 'paradigm' to
a more involved data structure, the dynamic mesh.</p>
<p>We do a load of mesh processing at <a href="http://pathengine.com">PathEngine</a>,
both <em>during content-processing</em> and <em>at SDK run-time</em>.</p>
<p>Sometimes this involves modifying the mesh, and we need dynamic mesh
data structures to support this.</p>
<p>We started out using a traditional pointer-based, 'list-like' mesh data structure,
but switched to a 'vector-like' approach,
based on contiguous buffers, and from iterators to direct indexing..</p></div>
            <a href="/13/vector-meshes">Post</a>,
            <a href="/13/vector-meshes#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Feb. 26, 2015, 5:32 p.m.</div>
        <div class="titleBlock">
            <a href="/12/vector-hosted-lists">
                <h1 class="title">Vector Hosted Lists</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>Vectors are great when adding or removing elements at the end of a sequence,
but not so hot when deleting elements at arbitrary positions.</p>
<p>If that's a requirement, you might find yourself reaching for a pointer-based list.</p>
<p>Not so fast!</p>
<p>Memory locality is important, contiguous buffers are a really good thing,
and a standard vector will often out-perform pointer-based lists
even where you perform non-contiguous, list-style modifications such as arbitrary element deletion.</p>
<p>And we can 'host' a list <em>within</em>
a vector to get the advantages of a contiguous buffer
<em>at the same time</em> as 0(1) complexity for these kinds of manipulations.</p></div>
            <a href="/12/vector-hosted-lists">Post</a>,
            <a href="/12/vector-hosted-lists#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Oct. 20, 2014, 1:30 p.m.</div>
        <div class="titleBlock">
            <a href="/11/atomic-cross-chain-exchange">
                <h1 class="title">Atomic Cross-Chain Exchange</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>Cryptocurrencies are great for <em>decentralised payments</em>.
Once you have bitcoin
you can pay arbitrary destinations
without the need to trust in, or get the approval of, any third party.</p>
<p>But what about if you want to <em>exchange</em> your bitcoin for something else,
say another cryptocurrency?</p>
<p>This normally means registering with a third party exchange service, and
trusting that third party service not to lose your funds during the exchange.
It's not ideal, and doesn't really fit with the whole decentralised <em>thing</em>!</p>
<p>It turns out that proper atomic exchange between two cryptocurrencies isn't
fundamentally hard,
as long as you have the right building blocks,
and this is something that I think should then be <em>standardised</em> across different cryptocurrencies.</p></div>
            <a href="/11/atomic-cross-chain-exchange">Post</a>,
            <a href="/11/atomic-cross-chain-exchange#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Sept. 26, 2014, 11:38 a.m.</div>
        <div class="titleBlock">
            <a href="/10/infinitesimal-offset-meshes">
                <h1 class="title">Infinitesimal Offset Meshes</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>In PathEngine, we do a lot of stuff on the surfaces of ground meshes.</p>
<p>One example is tracking the ground position for a moving agent,
which is implemented as traversal along a 2D line through a mesh.</p>
<p>When coding stuff like this the need to
check and handle special case conditions like vertex crossings, or traversal exactly along an edge,
can add a lot of complexity.</p>
<p>In this post I talk about a technique we use in PathEngine,
based on an <em>infinitesimally offset mesh model</em>, to eliminate
these kinds of special case conditions and simplify our mesh based geometry.</p></div>
            <a href="/10/infinitesimal-offset-meshes">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">July 1, 2014, 3:44 p.m.</div>
        <div class="titleBlock">
            <a href="/9/fast-resettable-flag-vector">
                <h1 class="title">Fast Resettable Flag Vector</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>Another custom container post for my <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">Vectors and Vector Based Containers</a> series.</p>
<p>In this post I'll look at an alternative implementation of the humble bit vector, designed specifically for optimising zero fill operations.</p>
<p>It's not a new technique, and not particularly complicated to implement,
but it's not completely obvious, and it's something that gave us some noticeable speedups when applied to
PathEngine so I think it's worth sharing here.</p></div>
            <a href="/9/fast-resettable-flag-vector">Post</a>,
            <a href="/9/fast-resettable-flag-vector#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">June 20, 2014, 2:54 p.m.</div>
        <div class="titleBlock">
            <a href="/8/fast-blockchain-scanning">
                <h1 class="title">Fast Blockchain Scanning</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>(Another post about bitcoin RPC from Python.)</p>
<p>For certain bitcoin applications you'll need to perform some kind of processing on <em>all of the transactions</em> coming through on the bitcoin block chain.
In a bitcoin wallet application, for example, you need to check each new transaction to identify any outputs which are spendable by the wallet, and add the corresponding amounts to the wallet balance.</p>
<p>In this post we'll look at how to do this with bitcoin RPC calls.</p>
<p>Theres one obvious way to achieve this, but the obvious approach requires a full transaction index, and also works out to be quite inefficient.
I'll show you a less obvious, and more efficient way to do this, without the transaction index requirement.</p></div>
            <a href="/8/fast-blockchain-scanning">Post</a>,
            <a href="/8/fast-blockchain-scanning#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">April 7, 2014, 10:02 a.m.</div>
        <div class="titleBlock">
            <a href="/7/bitcoin-rpc-from-python">
                <h1 class="title">Bitcoin RPC from Python</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>The reference bitcoin client includes a powerful API and RPC interface.</p>
<p>In this post I show you how to call into this from Python
(which is something that turns out to be almost trivially easy to set up).</p>
<p>Python can work well as a kind of (overpowered) scripting language for automating
complicated tasks through the bitcoin reference client, but this is also a great way to get started out
if you're interested in writing more involved software that works with bitcoin transactions or the bitcoin blockchain.</p></div>
            <a href="/7/bitcoin-rpc-from-python">Post</a>,
            <a href="/7/bitcoin-rpc-from-python#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Jan. 21, 2014, 4:55 p.m.</div>
        <div class="titleBlock">
            <a href="/6/custom-vector-allocation">
                <h1 class="title">Custom Vector Allocation</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>(Number 6 in a <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">series of posts</a> about Vectors and Vector based containers.)</p>
<p>A few posts back I talked about the idea of 'rolling your own' STL-style vector class,
based on my experiences with this at PathEngine.</p>
<p>In <a href="http://upcoder.com/3/roll-your-own-vector/">that original post</a>
and <a href="http://upcoder.com/4/avoid-resize/">these</a> <a href="http://upcoder.com/5/zero-initialisation-for-classes">two</a> follow-ups
I talked about the general approach and also some specific performance tweaks that actually helped <em>in practice for our vector use cases</em>.</p>
<p>I haven't talked about custom memory allocation yet, however.
This is something that's been cited in a number of places as a key reason for switching away from std::vector
so I'll come back now and look at the approach we took for this (which is pretty simple, but nonstandard, and also <em>pre C++11</em>),
and assess some of the implications of using this kind of non-standard approach.</p>
<p>I approach this from the point of view of a custom vector implementation, but I'll be talking about some issues with memory customisation that also apply more
generally.</p></div>
            <a href="/6/custom-vector-allocation">Post</a>,
            <a href="/6/custom-vector-allocation#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Dec. 22, 2013, 4:41 p.m.</div>
        <div class="titleBlock">
            <a href="/5/zero-initialisation-for-classes">
                <h1 class="title">Zero Initialisation for Classes</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>(Number 5 in a <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">series of posts</a> about Vectors and Vector based containers.)</p>
<p>This is a response to comments on
a previous post,
<a href="http://upcoder.com/3/roll-your-own-vector">roll your own vector</a>,
and has also been rewritten and updated fairly significantly since first posted.</p>
<p>In <a href="http://upcoder.com/3/roll-your-own-vector">roll your own vector</a> I talked about a change
we made to the initialisation semantics for PathEngine's custom vector class.
In my first followup post I looked more closely at possibilities for replacing resize() with reserve() (which can avoid the initialisation issue in many cases),
but so far I'm been concentrating pretty much exclusively on zero initialisation for <em>built-in types</em>.
In this post I come back to look at the issue of initialisation semantics for <em>class</em> element types.</p></div>
            <a href="/5/zero-initialisation-for-classes">Post</a>,
            <a href="/5/zero-initialisation-for-classes#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Dec. 20, 2013, 4:39 p.m.</div>
        <div class="titleBlock">
            <a href="/4/avoid-resize">
                <h1 class="title">Avoid resize()?</h1>
            </a>
            
            <h1 class="tagline">(Uninitialised buffers and std::vector)</h1>
            
        </div>
        <div class="summary">
            <div class="body"><p>(Number 4 in a <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">series of posts</a> about Vectors and Vector based containers.)</p>
<p>This post is essentially a response to feedback to
<a href="http://upcoder.com/3/roll-your-own-vector">this</a> previous post.</p>
<p>In that post I talked about a change we made to the initialisation semantics for PathEngine's custom vector class,
and described a specific use case where this can make a difference, with that use case involving calls to the vector resize() method.</p>
<p>In the comments for that post, Herb Sutter says:</p>
<blockquote>
<p>Thomas, I think the point is that "reserve + push_back/emplace_back" is the recommended style and the one people do use. Really resize() is not used often in the code I've seen; you use resize() only when you want that many extra default-constructed elements, since that's what it's for.</p>
</blockquote>
<p>In this post I'll be looking into our use case in a bit more detail, and in particular whether or not a resize() call is actually required.</p></div>
            <a href="/4/avoid-resize">Post</a>,
            <a href="/4/avoid-resize#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Dec. 15, 2013, 12:14 p.m.</div>
        <div class="titleBlock">
            <a href="/3/roll-your-own-vector">
                <h1 class="title">Roll-Your-Own Vector</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>(Third in a <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">series of posts</a> about Vectors and Vector based containers.)</p>
<p>STL vectors offer a great combination of dynamically resizing convenience and low level contiguous buffer accessing performance,
but std::vector is not the only option,
and custom implementations of this container can sometimes be a better fit for your specific requirements.</p></div>
            <a href="/3/roll-your-own-vector">Post</a>,
            <a href="/3/roll-your-own-vector#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Nov. 22, 2013, 12:45 p.m.</div>
        <div class="titleBlock">
            <a href="/2/efficient-vectors-of-vectors">
                <h1 class="title">Efficient Vectors of Vectors</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>(Second in a <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">series of posts</a> about Vectors and Vector based containers.)</p>
<p>STL style vectors are convenient because they hide the details of internal buffer management, and present a simplified interface,
but sometimes convenience can be a trap!</p>
<p>In my previous post I touched briefly on STL vectors with non-simple element types,
and mentioned the 'vector of vectors' construct in particular as a specific source of memory woes.</p>
<p>In this post I'll talk about this construct in more detail,
explain a bit about why there is an issue,
and go on to suggest a fairly straightforward alternative for many situations.</p></div>
            <a href="/2/efficient-vectors-of-vectors">Post</a>,
            <a href="/2/efficient-vectors-of-vectors#comments">Comments</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Nov. 18, 2013, 10:39 a.m.</div>
        <div class="titleBlock">
            <a href="/1/using-stl-vectors">
                <h1 class="title">Using STL Vectors</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"><p>(First in a <a href="http://upcoder.com/series/1/vectors-and-vector-based-containers/">series of posts</a> about Vectors and Vector based containers.)</p>
<p>STL style vectors are a pretty useful construct.</p>
<p>I remember coming to C++ (and the STL) from a background in lower level programming, and finding STL vectors a bit surprising,
with the idea of <em>amortized constant time</em> complexity and so on.</p>
<p>And then it was actually something of a minor revolution just to be able to set up a contiguous data buffer, without any significant programming effort,
and <em>without knowing the maximum required buffer size in advance</em>.</p>
<p>Before we had C++ and the STL I remember a common source of errors being dynamically generated data overflowing fixed buffers,
which is something we just don't see any more, thanks in no small part to the humble vector (and brethren).</p>
<p>But convenience can come at a cost, and there's some stuff you need to be careful about
when applying STL vectors in performance critical situations.</p>
<p>In this post I'll discuss the
main ways in which STL style vectors are applied in PathEngine,
and look at some of the key performance and memory points coming out of this.</p></div>
            <a href="/1/using-stl-vectors">Post</a>
        </div>
        <hr>
    </div>
    
    <div class="summaryBlock">
        <div class="time">Nov. 18, 2013, 10 a.m.</div>
        <div class="titleBlock">
            <a href="/0/about-the-author">
                <h1 class="title">About the Author</h1>
            </a>
            
        </div>
        <div class="summary">
            <div class="body"></div>
            <a href="/0/about-the-author">Post</a>
        </div>
        
    </div>
    

            </div>
            <div class="sidebar">
                <p>
                    <a class="feed" href="/feed">RSS feed</a>
                </p>
                <p>
                Posts (most recent first)
                </p>
                <p>
                
                    <a href="/20/cc-include-guidelines">C/C++ Include Guidelines</a> <br/>
                
                    <a href="/19/automatic-object-linkage-with-include-graphs">Automatic Object Linkage, with Include Graphs</a> <br/>
                
                    <a href="/18/static-libs-do-not-modular-make">Static Libs Do Not Modular Make</a> <br/>
                
                    <a href="/17/who-owns-who">Who Owns Who?</a> <br/>
                
                    <a href="/16/skeleton-meshes">Skeleton Meshes</a> <br/>
                
                    <a href="/15/measure-memory-allocation-cost-by-eliminating-it">Measure Memory Allocation Cost, by Eliminating It</a> <br/>
                
                    <a href="/14/pre-rendering-pdfs-for-mobile-devices">Pre-Rendering PDFs for Mobile Devices</a> <br/>
                
                    <a href="/13/vector-meshes">Vector Meshes</a> <br/>
                
                    <a href="/12/vector-hosted-lists">Vector Hosted Lists</a> <br/>
                
                    <a href="/11/atomic-cross-chain-exchange">Atomic Cross-Chain Exchange</a> <br/>
                
                    <a href="/10/infinitesimal-offset-meshes">Infinitesimal Offset Meshes</a> <br/>
                
                    <a href="/9/fast-resettable-flag-vector">Fast Resettable Flag Vector</a> <br/>
                
                    <a href="/8/fast-blockchain-scanning">Fast Blockchain Scanning</a> <br/>
                
                    <a href="/7/bitcoin-rpc-from-python">Bitcoin RPC from Python</a> <br/>
                
                    <a href="/6/custom-vector-allocation">Custom Vector Allocation</a> <br/>
                
                    <a href="/5/zero-initialisation-for-classes">Zero Initialisation for Classes</a> <br/>
                
                    <a href="/4/avoid-resize">Avoid resize()?</a> <br/>
                
                    <a href="/3/roll-your-own-vector">Roll-Your-Own Vector</a> <br/>
                
                    <a href="/2/efficient-vectors-of-vectors">Efficient Vectors of Vectors</a> <br/>
                
                    <a href="/1/using-stl-vectors">Using STL Vectors</a> <br/>
                
                    <a href="/0/about-the-author">About the Author</a> <br/>
                
                </p>
                <p>
                Series
                </p>
                <p>
                
                    <a href="/series/2/pathengine-meshes">PathEngine Meshes</a> <br/>
                
                    <a href="/series/1/vectors-and-vector-based-containers">Vectors and Vector Based Containers</a> <br/>
                
                </p>
                <p>
                Blogs I follow
                </p>
                <p>
                
                    <a href="http://www.brendangregg.com/blog">Brendan Gregg</a> <br/>
                
                    <a href="http://danluu.com">Dan Luu</a> <br/>
                
                    <a href="http://randomascii.wordpress.com">Random ASCII</a> <br/>
                
                    <a href="http://www.codinghorror.com/blog">Coding Horror</a> <br/>
                
                    <a href="http://nickdesaulniers.github.io">Nick Desaulniers</a> <br/>
                
                    <a href="http://www.codercorner.com/blog">Coder Corner</a> <br/>
                
                    <a href="http://gameangst.com">Game Angst</a> <br/>
                
                    <a href="http://bitsquid.blogspot.com">Bitsquid</a> <br/>
                
                    <a href="http://casual-effects.blogspot.com">Casual Effects</a> <br/>
                
                    <a href="http://digestingduck.blogspot.com">Digesting Duck</a> <br/>
                
                    <a href="http://c0de517e.blogspot.fr">c0de517e</a> <br/>
                
                    <a href="http://atilanevesoncode.wordpress.com">Atila on Code</a> <br/>
                
                    <a href="http://prog21.dadgum.com">James Hague</a> <br/>
                
                    <a href="http://eli.thegreenplace.net">Eli Bendersky</a> <br/>
                
                    <a href="http://lucumr.pocoo.org">Armin Ronacher</a> <br/>
                
                    <a href="http://nedbatchelder.com/blog">Ned Batchelder</a> <br/>
                
                    <a href="http://www.jeffknupp.com/blog/archives">Hackers Gonna Hack</a> <br/>
                
                    <a href="http://mechanical-elephant.com">Mechanical Elephant</a> <br/>
                
                    <a href="http://bartoszmilewski.com">Bartosz Milewski</a> <br/>
                
                </p>
            </div>
        </div>
    </div>
    <div id="footer">
    
    
    </div>
    

</body>
</html>
